#!/usr/bin/python2.6
# -*- coding: utf-8 -*-
import threading # 导入threading模块来支持多线程
import json # 导入json模块来处理JSON数据
import socket # 导入socket模块用于网络通信
import queue # 导入queue模块，提供了同步的、线程安全的队列类
import time # 导入time模块用于处理时间相关的任务
# from interests import INTEREST
from data import DATA
import hashlib # 导入hashlib模块用于加密哈希


BCAST_PORT = 33334 # 定义广播端口为33334

# 定义一个函数来对字符串进行md5哈希，同client.py中的hashstr函数
# Define a function to perform md5 hashing of strings, the same as the hashstr function in client.py
def hashstr(string):
    md5 = hashlib.md5()
    md5.update(string.encode('utf-8'))
    return md5.hexdigest()

# 定义一个函数来获取本机的IP地址，同web.py中的同名函数
# Define a function to obtain the IP address of the machine, the same as the function of the same name in web.py
def get_host_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(('8.8.8.8', 80))
        ip = s.getsockname()[0]
    finally:
        s.close()
    return ip

# 定义Server类，继承自threading.Thread
# 这意味着每个 Server 实例可以作为一个独立的线程运行，这在处理并发网络请求时非常有用
# Define Server class, inherited from threading.Thread
# This means that each Server instance can run as an independent thread, which is very useful when handling concurrent network requests
class Server(threading.Thread):

    # 初始化函数
    #Initialization function
    def __init__(self, serverID, server_name, basic_port):
        # 初始化Server类的父类threading.Thread
        # Initialize the parent class threading.Thread of the Server class
        threading.Thread.__init__(self)

        # 获取并设置服务器的IP地址
        # Get and set the IP address of the server
        self.HOST = get_host_ip()

        self.basic_port = basic_port # 基础端口 #Basic port

        # 根据serverID计算实际端口
        # Calculate the actual port based on serverID
        self.PORT_accept = self.basic_port + serverID

        # 创建字典记录服务器的IP地址和实际端口
        # Create a dictionary to record the IP address and actual port of the server
        self.ip_addr = {server_name: [self.HOST, self.PORT_accept]}
        
        # 点字典，可能用于记录网络中的其他节点
        # Point dictionary, may be used to record other nodes in the network
        self.point_dict = {}

        # 存储服务器ID，可能用于区分不同的服务实例
        # Storage server ID, which may be used to distinguish different service instances
        # This is the port generated by the data corresponding to the loop
        self.serverID = serverID  # 这个就是循环对应的数据产生的端口
        
        # 存储服务器的名称
        # The name of the storage server
        self.server_name = server_name

        # 网络字典，可能用于记录整个网络的拓扑或状态
        # Network dictionary, which may be used to record the topology or status of the entire network
        self.net_work = {}

        # 可能定义了队列大小或某种资源的数量上限。
        # May define a queue size or an upper limit on the number of certain resources.
        self.sizes = 100

        # FIB (Forwarding Information Base) 字典，用于存储路由信息
        # FIB (Forwarding Information Base) dictionary, used to store routing information
        self.fib = {}

        # 用于存储数据的字典
        # Dictionary for storing data
        self.data_dict = dict()

        # 利用 queue 模块创建一个队列，用于存放接收到的 "interest" 请求。
        # Use the queue module to create a queue to store received "interest" requests.
        self.interest_queue = queue.Queue(self.sizes)    # queue.Queue()
        
        # 定义了一个内容数量的限制或者是提供的内容数量
        # Defines a limit on the amount of content or the amount of content provided
        # This is the amount of information
        self.content_num = 100  # 这个就是信息的数量
        
        # class objects
        # 创建了 INTEREST 和 DATA 的实例，这些可能是处理网络兴趣包和数据包的类
        # Created instances of INTEREST and DATA, these may be classes that handle network interest and data packets
        # self.interest = INTEREST()
        self.data = DATA()

    # 在 Python 中，当你创建一个线程时，你通常会从 threading.Thread 类派生一个新类，并且重写该类的 run() 方法。
    # In Python, when you create a thread, you usually derive a new class from the threading.Thread class and override the run() method of that class.
    # run() 方法定义了线程启动后将要执行的操作。当你调用线程的 start() 方法时，它会在新的线程中调用 run() 方法。
    # The run() method defines the operations to be performed after the thread is started. When you call the thread's start() method, it calls the run() method in the new thread.
    def run(self):
        # run 方法会被线程启动时调用。
        # The run method will be called when the thread starts.
        # 创建了几个线程分别处理不同的任务。
        # Create several threads to handle different tasks.
        accept = threading.Thread(target=self.accept)  
        broadcast_iP = threading.Thread(target=self.broadcastIP)  
        update_list = threading.Thread(target=self.updateList)  
        interests = threading.Thread(target=self.interests_process) 
        
        # 启动上述创建的线程
        # Start the thread created above
        broadcast_iP.start()
        update_list.start()
        accept.start()
        interests.start()
        time.sleep(10)

        # 主线程等待这些辅助线程完成
        # The main thread waits for these auxiliary threads to complete
        accept.join()
        interests.join()

    # 构建环状的网络拓扑，定义了网络中每个节点的邻居节点
    # self.point_dict 包含网络中所有节点的信息，而 self.net_work 字典将每个节点标识（例如 'r0', 'r1' 等）映射到该节点的邻居节点标识的列表。
    # 这个方法保证了每个节点至少有两个邻居，即便在网络的边缘（第一个和最后一个节点）。这种网络拓扑可能是用来模拟一个环形网络，其中每个节点都连接到它的前一个和后一个节点
    # Build a ring-shaped network topology and define the neighbor nodes of each node in the network
    # self.point_dict contains information about all nodes in the network, while the self.net_work dictionary maps each node ID (e.g. 'r0', 'r1', etc.) to a list of that node's neighbor node IDs.
    # This method ensures that each node has at least two neighbors, even at the edge of the network (first and last nodes). This network topology may be used to simulate a ring network, where each node is connected to its previous and following nodes
    def get_network(self):
        # 遍历点字典，这个字典包含网络中所有节点的信息
        # Traverse the point dictionary, which contains information about all nodes in the network
        for i in range(len(self.point_dict)):

            # 如果是最后一个节点，它的邻居被设置为第一个节点和倒数第二个节点。
            # 这样做可能是为了形成一个闭环，使得网络中的每个节点都是连通的。
            # 如果网络中只有一个节点，则它的邻居只有它自己
            # If it is the last node, its neighbors are set to the first node and the penultimate node.
            # This may be done to form a closed loop so that every node in the network is connected.
            # If there is only one node in the network, its neighbor is only itself
            if i == len(self.point_dict) - 1:
                # Conditional expression, which sets the neighbor nodes of the node in the network based on the index i of the current iteration
                self.net_work['r' + str(i)] = {0, i - 1} if i >= 1 else {0} # 条件表达式，它根据当前迭代的索引i来设置网络中节点的邻居节点
                # 结束循环，因为已经添加了最后一个节点
                # End the loop because the last node has been added
                break
            
            # 如果是第一个节点，它的邻居被设置为第二个节点和最后一个节点
            # If it is the first node, its neighbors are set to the second node and the last node
            elif i == 0:
                self.net_work['r' + str(i)] = {i + 1, len(self.point_dict) - 1}
            
            # 对于网络中的中间节点，邻居被设置为前一个和后一个节点
            # For intermediate nodes in the network, neighbors are set to the previous and next nodes
            else:
                self.net_work['r' + str(i)] = {i - 1, i + 1}
        
        # 这个循环将邻居节点的集合转换为列表。
        # 这可能是因为列表比集合更容易索引和操作。
        # This loop converts the set of neighbor nodes into a list.
        # This may be because lists are easier to index and manipulate than sets.
        for k, v in self.net_work.items():
            self.net_work[k] = list(v)

    # 构建 FIB 表（转发信息库），确定数据包的转发路径
    # FIB是命名数据网络（NDN）中的一个关键概念，用于决定兴趣包（interest packets）如何在网络中转发
    # 旨在逐层构建出一个从源节点到网络中每个其他节点的最短路径映射
    # 在每次迭代中，upper_layer 包含的节点被用来探索新的节点（即它们的邻居），并确定这些新节点的下一跳（即它们在 FIB 中的值）。这样做可以确保网络中每个节点都可以通过最短路径到达源节点
    # Build a FIB table (forwarding information base) to determine the forwarding path of data packets
    # FIB is a key concept in Named Data Networks (NDN) and is used to determine how interest packets are forwarded in the network
    # Aims to build a shortest path mapping from the source node to every other node in the network layer by layer
    # In each iteration, the nodes contained in the upper_layer are used to explore new nodes (i.e., their neighbors) and determine the next hops of these new nodes (i.e., their values ​​in the FIB). This ensures that every node in the network can reach the source node via the shortest path
    def get_fib(self):
        try:
            # 初始化一个空集合，用来存放已经处理过的节点
            # Initialize an empty collection to store processed nodes
            key_set = set()

            # 获取网络中所有节点的集合
            # Get the set of all nodes in the network
            key_whole_set = set(self.net_work.keys())

            # 初始化包含当前服务器ID的节点列表，这将作为信息传播的起点
            # 第一次迭代中，upper_layer是源节点（服务器自身）
            # upper_layer: 表示当前考虑的节点的集合，在第一次迭代中，它包含的是源节点（通常是服务器自身）。
            # 这些节点被视为当前“层”或者搜索的当前“前沿”，在这个前沿中，每个节点都将被用来搜索它们的邻居节点。
            # new_layer: 当从 upper_layer 的每个节点扩展搜索到它们的邻居时，这些新发现的邻居节点被添加到 new_layer 中。
            # 在每次迭代结束时，new_layer 包含了下一层的节点，这些节点将在下一次迭代中成为新的搜索前沿。
            # Initialize the node list containing the current server ID, which will serve as the starting point for information dissemination
            # In the first iteration, upper_layer is the source node (the server itself)
            # upper_layer: Represents the set of nodes currently considered. In the first iteration, it contains the source node (usually the server itself).
            # These nodes are considered the current "layer" or the current "front" of the search, in which each node will be used to search for their neighbor nodes.
            # new_layer: As each node in upper_layer is expanded to search for their neighbors, these newly discovered neighbor nodes are added to new_layer.
            # At the end of each iteration, new_layer contains the nodes of the next layer, which will become the new search front in the next iteration.
            upper_layer = ['r' + str(self.serverID)]

            # 初始化计数器，用于避免可能的无限循环
            # Initialize the counter to avoid possible infinite loops
            a = 0

            # 分层的广度优先搜索
            # 如果还有未处理的节点，继续循环
            # 这个过程重复进行，直到所有节点都被探索过，并且它们的下一跳都被添加到 FIB 中。这个方法可以确保在无向图或者有向无环图中，
            # 从源节点到每个节点都有一条路径。在信息中心网络中，这样的 FIB 对于指导兴趣包（interest packets）从一个节点传输到请求数据的节点是必要的
            # Hierarchical breadth-first search
            # If there are still unprocessed nodes, continue looping
            # This process is repeated until all nodes have been explored and their next hops have been added to the FIB. This method can ensure that in an undirected graph or a directed acyclic graph,
            # There is a path from the source node to each node. In information-centric networks, such a FIB is necessary to direct the transmission of interest packets from one node to the node requesting the data.
            while key_set < key_whole_set:
                #increment counter
                a += 1 # 自增计数器

                # 如果计数器超过40，退出循环以防止潜在的无限循环
                # If the counter exceeds 40, exit the loop to prevent a potentially infinite loop
                if a > 40:
                    break
                
                # 新的层级，用于存储这一轮被处理的节点
                # New level used to store nodes processed in this round
                new_layer = []

                # 对于未处理的节点（key_whole_set - key_set 计算差集）
                # For unprocessed nodes (key_whole_set - key_set calculates the difference set)
                for key in key_whole_set - key_set:
                    # Traverse the nodes of the previous layer
                    for i in upper_layer: # 遍历上一层的节点
                        # 如果当前节点就是上层节点，或者上层节点是当前节点的邻居
                        # If the current node is the upper node, or the upper node is the neighbor of the current node
                        if key == i or int(i.strip('r')) in self.net_work[key]:
                            # 在FIB中为当前节点设置转发路径到上层节点
                            # Set the forwarding path for the current node in FIB to the upper node
                            self.fib[key] = i
                            # 将当前节点添加到已处理的节点集合中
                            # Add the current node to the processed node collection
                            key_set.add(key)
                            # 将当前节点添加到新的层级中，它可能会成为下一轮的上层节点
                            # Add the current node to the new level, it may become the upper node of the next round
                            new_layer.append(key)
                # 更新上层节点为这一轮处理的新层节点
                # Update the upper layer node to be the new layer node processed in this round
                upper_layer = new_layer
        except Exception as e: # 异常处理
            pass

    # 使用 UDP 广播服务器的 IP 地址和端口号
    # UDP 协议是一个无连接的协议，这意味着数据包（在这种情况下是IP地址）被发送到网络中，而不需要建立和维护一个持续的连接。
    # 由于这个原因，UDP通常用于广播和多播通信。在这个特定的上下文中，每10秒服务器就会广播一次它的IP地址，这样其他设备就可以知道它的存在，并且在需要的时候可以与它通信
    # Use the IP address and port number of the UDP broadcast server
    # The UDP protocol is a connectionless protocol, which means that packets (in this case IP addresses) are sent to the network without the need to establish and maintain a persistent connection.
    # For this reason, UDP is commonly used for broadcast and multicast communications. In this specific context, every 10 seconds the server broadcasts its IP address so that other devices are aware of its presence and can communicate with it if needed
    def broadcastIP(self):
        # # 创建一个新的socket对象，使用IPv4(AF_INET)，UDP协议(SOCK_DGRAM)，IPPROTO_UDP指明了使用UDP
        # Create a new socket object, using IPv4 (AF_INET), UDP protocol (SOCK_DGRAM), IPPROTO_UDP specifies the use of UDP
        server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)  # 这里创建的是UDP协议
        
        # 设置socket的选项，启用广播模式
        # SOL_SOCKET是正在使用的socket选项级别，SO_BROADCAST是指定广播的选项名称，1是选项值，启用广播
        # Set socket options and enable broadcast mode
        # SOL_SOCKET is the socket option level being used, SO_BROADCAST is the option name specifying broadcast, 1 is the option value, enabling broadcast
        server.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)  
        
        # 设置socket操作的超时时间为0.5秒
        # 如果sendto或recvfrom在0.5秒内没有完成，会抛出socket.timeout异常
        # Set the timeout for socket operation to 0.5 seconds
        # If sendto or recvfrom is not completed within 0.5 seconds, a socket.timeout exception will be thrown
        server.settimeout(0.5)

        # 将服务器的IP地址转换为JSON格式的字符串，然后编码为UTF-8字节串准备发送
        # Convert the server's IP address to a string in JSON format, and then encode it into a UTF-8 byte string to prepare for sending.
        message = json.dumps(self.ip_addr).encode('utf-8')
        
        # 无限循环，这意味着服务器会不停地发送广播
        # Infinite loop, which means the server will keep sending broadcasts
        while True:
            # 使用sendto方法发送编码后的消息
            # 消息被发送到特殊的'<broadcast>'地址，这是一个广播地址，消息将被发送给所有在BCAST_PORT端口监听的设备
            # Use the sendto method to send the encoded message
            # The message is sent to the special '<broadcast>' address, which is a broadcast address. The message will be sent to all devices listening on the BCAST_PORT port
            # Broadcast your IP to everyone
            server.sendto(message, ('<broadcast>', BCAST_PORT))  # 像所有的人广播自己IP
            
            # 休眠10秒，这个休眠时间决定了广播的间隔
            # Sleep for 10 seconds. This sleep time determines the broadcast interval.
            time.sleep(10)

    # 监听广播消息，并更新节点信息字典
    # 这个函数的主要目的是维护网络中的节点信息，它监听广播消息并更新服务器的本地网络拓扑。
    # 通过这样做，服务器能够跟踪网络中的其他节点，并根据这些信息更新其路由决策。这对于在动态变化的网络环境中维持有效的通信至关重要
    # Listen to broadcast messages and update the node information dictionary
    # The main purpose of this function is to maintain node information in the network. It listens to broadcast messages and updates the local network topology of the server.
    # By doing this, the server is able to keep track of other nodes in the network and update its routing decisions based on this information. This is critical to maintaining effective communications in a dynamically changing network environment
    def updateList(self):
        # 服务器名称字段下存储了自身的IP和端口信息
        # The server name field stores its own IP and port information.
        self.point_dict[self.server_name] = (self.HOST, self.PORT_accept)
        
        # 创建一个UDP协议
        # Create a UDP protocol
        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)  
        
        # 设置socket的选项，以便在socket关闭后立即重新使用端口
        # SO_REUSEPORT允许多个应用程序绑定到同一端口，用于负载均衡
        # Set options for the socket to reuse the port immediately after the socket is closed
        # SO_REUSEPORT allows multiple applications to bind to the same port for load balancing
        client.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        
        # 一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性
        # Generally when sending UDP datagrams, it is hoped that the data sent by the socket has broadcast characteristics.
        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        
        # 绑定socket到一个空字符串表示的地址和BCAST_PORT端口
        # 这样设置是为了监听所有接口上的这个端口的广播消息
        # Bind the socket to the address and BCAST_PORT port represented by an empty string
        # This setting is to monitor the broadcast messages of this port on all interfaces.
        client.bind(("", BCAST_PORT))   

        # 初始化一个计数器，用于周期性地打印网络状态信息
        # Initialize a counter for periodically printing network status information
        count_i = 0

        # 无限循环，这意味着服务器会不停地监听广播消息
        # Infinite loop, which means the server will continue to listen for broadcast messages
        while True:
            # Update counter
            count_i += 1 # 更新计数器

            # 接收从网络上的任意源发来的最大1024字节的数据
            # Receive data up to 1024 bytes from any source on the network
            data, _ = client.recvfrom(1024)

            # 解码并将接收到的JSON格式的数据转换成Python字典
            # Decode and convert the received JSON format data into a Python dictionary
            data = json.loads(data.decode('utf-8'))

            # 解包字典，获取发送方的服务器名和地址信息
            # 地址信息包括host和port
            # Unpack the dictionary and obtain the sender’s server name and address information
            # Address information includes host and port
            (key, value), = data.items()
            host = value[0]
            port = value[1]
            point = (host, port)

            # 检查接收到的点是否不是自己，并且之前还没有被记录过
            # Check whether the received point is not itself and has not been recorded before
            if point != (self.HOST, self.PORT_accept) and key not in self.point_dict.keys():
                # 如果是新点，则加入到点字典中
                # If it is a new point, add it to the point dictionary
                self.point_dict[key] = point
                # 更新网络拓扑信息
                # Update network topology information
                self.get_network()

            # 更新转发信息库
            # Update forwarding information database
            self.get_fib()

            # 每当计数器达到10的倍数时，打印网络信息，帮助调试和监控
            # Whenever the counter reaches a multiple of 10, print network information to help debugging and monitoring
            if count_i % 10 == 0:
                print('net_work: {}'.format(self.net_work))
                print('FIB: {}'.format(self.fib))
                print(('point {}'.format(self.point_dict.keys())))
            
            # 休眠10秒，减缓循环速度，减少资源消耗
            # Sleep for 10 seconds to slow down the loop speed and reduce resource consumption
            time.sleep(10)
    
    # 接收连接并处理兴趣包（interests）和数据包（data）
    # 这个服务器既可以建立服务也可以发送信息
    # 这个函数负责接受和处理来自客户端的不同类型的网络请求，包括接收数据查询请求、处理数据传输，并且在必要时将请求转发到其他节点。
    # 同时，它也负责管理与客户端的连接和服务器资源
    # Receive connections and process interest packets (interests) and data packets (data)
    # This server can both create services and send information
    # This function is responsible for accepting and processing different types of network requests from clients, including receiving data query requests, processing data transmission, and forwarding requests to other nodes when necessary.
    # At the same time, it is also responsible for managing the connection with the client and server resources
    def accept(self):  
        # 创建一个基于IPv4和TCP的socket
        # Create a socket based on IPv4 and TCP
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # 将socket绑定到本地主机的接受端口
        # Bind the socket to the local host's accept port
        server.bind((self.HOST, self.PORT_accept))
        
        # 开始监听传入的连接请求，最多可以排队等待的连接数为11
        # Start listening for incoming connection requests. The maximum number of connections that can be queued is 11.
        server.listen(11)
        
        # 开始一个无限循环，等待并处理连接
        # Start an infinite loop, waiting for and processing connections
        while True:
            # 接受一个新的连接
            # Accept a new connection
            # This accept function is the accept function defined in socket, and conn is the connection between the server and the client.
            conn, addr = server.accept() # 这个accept函数是socket中定义的accept函数，conn是服务器端和客户端之间的连接
            # 接收从客户端发送的数据包，大小限制为1024字节
            # Receive data packets sent from the client, the size is limited to 1024 bytes
            packet = conn.recv(1024)
            # 将接收的数据包（预期为JSON格式）解码并加载为Python字典
            # Decode and load the received data packet (expected to be in JSON format) into a Python dictionary
            packet = json.loads(packet.decode('utf-8'))
            # 从数据包中获取'type'字段，决定接下来的处理流程
            # Get the 'type' field from the data packet to determine the next processing flow
            Type = packet['type']

            # 如果数据包类型是'interest'，意味着这是一个兴趣包（请求数据）
            # If the packet type is 'interest', it means this is an interest packet (request data)
            if Type == 'interest':
                # 计算内容名称的哈希值
                # Calculate the hash value of the content name
                hash_string = hashstr(packet['content_name'])

                # 将兴趣包存储在data_dict字典中，以哈希值为键
                # Store the interest package in the data_dict dictionary, with the hash value as the key
                self.data_dict[hash_string] = packet

                # 打印接收信息的日志
                # Print the log of received information
                print('node {} receive the information {}'.format(self.server_name, packet['content_name']))
            
            # 如果数据包类型是'data'，意味着这是一个数据包（包含请求的数据）
            # If the packet type is 'data', it means this is a data packet (containing the requested data)
            elif Type == 'data':
                # 打印数据包内容名称的哈希值
                # Print the hash value of the packet content name
                print(hashstr(packet['content_name']))
                # 如果哈希值在data_dict的键中，说明请求的数据在本地可用
                # If the hash value is in the key of data_dict, it means that the requested data is available locally.
                if hashstr(packet['content_name']) in self.data_dict.keys():
                    # 获取哈希值对应的数据
                    # Get the data corresponding to the hash value
                    information = self.data_dict[hashstr(packet['content_name'])]
                    # 将数据发送回请求的客户端
                    # Send data back to the requesting client
                    # Send the entire package at once
                    conn.sendall(json.dumps(information).encode('utf-8'))  # 一次性将整个包发完
                else:
                    # 如果本地没有数据，则准备转发数据包
                    # If there is no data locally, prepare to forward the data packet
                    packet_forward = self.data.Send_data(self.net_work[self.server_name], self.fib, packet)
                    # 如果有转发信息
                    # If there is forwarding information
                    if packet_forward:
                        # 创建一个新的socket进行连接
                        # Create a new socket to connect
                        serve_check = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        
                        # 连接到下一个节点
                        # Connect to the next node
                        serve_check.connect((self.point_dict['r' + str(packet_forward[0])][0], self.basic_port + packet_forward[0]))
                        
                        # 发送数据包
                        # Send packet
                        serve_check.sendall(json.dumps(packet_forward[1]).encode('utf-8'))
                        
                        # 设置socket超时时间
                        # Set socket timeout
                        serve_check.settimeout(50)

                        # 收到回复信息
                        # Receive reply message
                        information = serve_check.recv(1024)

                        # 解码回复数据
                        # Decode reply data
                        information = json.loads(information.decode('utf-8'))
                        
                        # 如果收到回复
                        # If a reply is received
                        if information:
                            # 发送数据给原始请求者
                            # Send data to original requester
                            conn.sendall(json.dumps(information).encode('utf-8'))
                            # 关闭连接
                            # Close the connection
                            conn.close()
                            # 如果回复中包含'content_name'，更新本地数据字典
                            # If the reply contains 'content_name', update the local data dictionary
                            if 'content_name' in information.keys():
                                hash_string = hashstr(information['content_name'])
                                self.data_dict[hash_string] = information
                            # 关闭与下一个节点的连接
                            # Close the connection to the next node
                            serve_check.close()

                    # 如果无法转发，则向客户端发送'not found'状态
                    # If forwarding is not possible, send 'not found' status to client
                    else:
                        information = {
                            'status': 'not found'
                        }
                        conn.sendall(json.dumps(information).encode('utf-8'))
            
            # 如果数据包类型是'sensor'，意味着这是一个来自传感器的数据包
            # If the packet type is 'sensor', it means this is a packet from a sensor
            elif Type == 'sensor':
                # 计算内容名称的哈希值
                # Calculate the hash value of the content name
                hash_string = hashstr(packet['content_name'])
                # 存储传感器数据包
                # Store sensor data packets
                self.data_dict[hash_string] = packet
                # 包的类型改为interest
                # Change the package type to interest
                packet['type'] = 'interest'
                # 将这个 packet 放入 interest_queue 队列中”，以便另一个线程可以稍后处理它
                # Put this packet into the interest_queue queue" so that another thread can process it later
                self.interest_queue.put(packet)
                information = {
                    'status': 'node receive information'
                }
                # 将information发送给请求的客户端
                # Send information to the requesting client
                conn.sendall(json.dumps(information).encode('utf-8'))

                # 关闭socket
                # Close socket
                conn.close()

    # 处理队列中的兴趣包，将它们转发给网络中的其他节点
    # 这个函数的目的是处理队列中的兴趣包，通过网络将它们转发到关联的其他节点，以查找和检索请求的数据
    # Process interest packets in the queue and forward them to other nodes in the network
    # The purpose of this function is to process Interest packets in the queue and forward them through the network to other associated nodes to find and retrieve the requested data
    def interests_process(self):
        # 无限循环
        # Infinite loop
        while True:
            # 检查队列是否为空，若为空，则继续等待直到有兴趣包到达
            # Check whether the queue is empty. If it is empty, continue to wait until the interest packet arrives.
            if self.interest_queue.empty():
                continue
            else:
                # 从队列中取出一个兴趣包
                # Take out an Interest packet from the queue
                packet = self.interest_queue.get()
                try:
                    # 遍历与当前服务器节点相关联的所有网络节点，环装的网络拓扑结构，r1和r0, r2相关联
                    # Traverse all network nodes associated with current server node, network topology of ring, r1 is associated with r0, r2
                    for i in range(len(self.net_work[self.server_name])):
                        # 为每一个关联节点创建一个新的 TCP socket 连接
                        # Create a new TCP socket connection for each associated node
                        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        # 与每个节点的指定地址和端口建立连接
                        # Establish a connection with the specified address and port of each node
                        server.connect((self.point_dict['r'+str(self.net_work[self.server_name][i])][0], self.basic_port + self.net_work[self.server_name][i]))
                        # 将 JSON 格式的兴趣包发送到相应的节点
                        # Send the interest packet in JSON format to the corresponding node
                        server.sendall(json.dumps(packet).encode('utf-8'))
                        server.close()
                # 异常处理
                # Exception handling
                except Exception as e:
                    pass

# 兴趣包的结构
# Structure of interest package
"""
{'type': 'interest', 'interest_ID': '20000', 'content_name': 'r6/91'}
"""

# 补充知识
# 在信息中心网络（Information Centric Networking, ICN）和特别是在命名数据网络（Named Data Networking, NDN）中，网络兴趣包（interest packets）和数据包（data packets）是核心的概念。它们的作用如下：
# Supplementary knowledge
# In Information Centric Networking (ICN) and especially in Named Data Networking (NDN), network interest packets (interest packets) and data packets (data packets) are core concepts. Their functions are as follows:

# 网络兴趣包（Interest Packets）
# 内容请求：兴趣包用来表达对数据的需求。它包含了请求特定数据的名称，如一个文件、视频流或其他数据。
# 路由：它们根据命名数据而不是端点地址（如IP地址）被路由。这意味着网络设备（如路由器）会根据数据的名称来转发兴趣包。
# 去中心化：它允许用户请求内容而不需要知道内容的实际位置，因为网络将负责找到并传送数据回复。
# 缓存：网络中的节点可以缓存数据，使得相同的兴趣包可以被本地缓存的数据满足，降低了对原始数据源的需求和延迟。
# Network Interest Packets
# Content request: Interest packets are used to express requirements for data. It contains the name of the requested specific data, such as a file, video stream, or other data.
# Routing: They are routed based on naming data rather than endpoint addresses (such as IP addresses). This means that network devices (such as routers) forward Interest packets based on the name of the data.
# Decentralization: It allows users to request content without knowing the actual location of the content, as the network will be responsible for finding and delivering the data reply.
# Caching: Nodes in the network can cache data, so that the same interest packet can be satisfied by locally cached data, reducing the demand and delay on the original data source.

# 数据包（Data Packets）
# 内容传输：当一个节点（如服务器或路由器）收到一个兴趣包并且它拥有或者可以获取所请求的数据，它会用数据包响应。
# 验证：数据包通常包含签名或其他形式的验证信息，以确保数据的完整性和来源的真实性。
# 满足请求：数据包是对兴趣包的直接响应，只有当有兴趣包请求时，数据包才会被发送。
# 无状态传输：与传统的IP网络不同，数据包的传输是无状态的，意味着它们不需要预先建立的连接。
# Data Packets
# Content transfer: When a node (such as a server or router) receives an Interest packet and it has or can obtain the requested data, it responds with a data packet.
# Verification: Data packets often contain signatures or other forms of verification information to ensure the integrity of the data and the authenticity of the source.
# Satisfy the request: The data packet is a direct response to the Interest packet. The data packet will only be sent when there is an Interest packet request.
# Stateless transmission: Unlike traditional IP networks, the transmission of data packets is stateless, meaning that they do not require a pre-established connection.


# 在ICN/NDN的上下文中，兴趣包和数据包的交互定义了网络通信的方式。发送者不发送数据到特定的地址，而是广播它对特定数据的兴趣。网络中的节点负责正确路由这些兴趣包到数据源，并将数据返回给请求者。这种模式强调了数据本身的重要性，而不是数据的位置或者数据通信的具体终点。
# In the context of ICN/NDN, the interaction of Interest packets and Data packets defines the way network communication is performed. The sender does not send data to a specific address, but rather broadcasts its interest in specific data. Nodes in the network are responsible for correctly routing these Interest packets to the data source and returning the data to the requester. This model emphasizes the importance of the data itself, rather than the location of the data or the specific endpoint of the data communication.
